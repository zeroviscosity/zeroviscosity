extends ../post

block content
  section.panel
    h3 TL;DR <span class="image-wrapper" data-width="450" data-height="363" data-s3-src="#{post.slug}/tldr.jpg"></span>
    p This post introduces some key concepts in D3 by building up an example, step by step, from a bare-bones pie chart to an interactive, animated donut chart that loads external data. If you're wondering why a pie/donut chart was chosen, there's a <a href="#why-a-pie">section below</a> that outlines the reasons for that choice. For the enough-of-this-jibber-jabber-show-me-the-code types out there, here is a breakdown of the aforementioned steps:
    ul
      li <a href="#step-1">Step 1</a> A Basic Pie Chart (<a href="https://github.com/zeroviscosity/d3-js-step-by-step-part-1/blob/master/step-1-pie.html" target="_blank">Code</a> | <a href="/static/d3-js-step-by-step-part-1/step-1-pie.html" target="_blank">Demo</a>)
      li <a href="#step-2">Step 2</a> A Basic Donut Chart (<a href="https://github.com/zeroviscosity/d3-js-step-by-step-part-1/blob/master/step-2-donut.html" target="_blank">Code</a> | <a href="/static/d3-js-step-by-step-part-1/step-2-donut.html" target="_blank">Demo</a>)
      li <a href="#step-3">Step 3</a> Adding a Legend (<a href="https://github.com/zeroviscosity/d3-js-step-by-step-part-1/blob/master/step-3-legend.html" target="_blank">Code</a> | <a href="/static/d3-js-step-by-step-part-1/step-3-legend.html" target="_blank">Demo</a>)
      li <a href="#step-4">Step 4</a> Loading External Data (<a href="https://github.com/zeroviscosity/d3-js-step-by-step-part-1/blob/master/step-4-external-data.html" target="_blank">Code</a> | <a href="/static/d3-js-step-by-step-part-1/step-4-external-data.html" target="_blank">Demo</a>)
      li <a href="#step-5">Step 5</a> Adding Tooltips (<a href="https://github.com/zeroviscosity/d3-js-step-by-step-part-1/blob/master/step-5-tooltips.html" target="_blank">Code</a> | <a href="/static/d3-js-step-by-step-part-1/step-5-tooltips.html" target="_blank">Demo</a>)
      li <a href="#step-6">Step 6</a> Animating Interactivity (<a href="https://github.com/zeroviscosity/d3-js-step-by-step-part-1/blob/master/step-6-animation.html" target="_blank">Code</a> | <a href="/static/d3-js-step-by-step-part-1/step-6-animation.html" target="_blank">Demo</a>)
    p <strong>NOTE:</strong> Because we're building things up step by step, the source code contains <code>NEW</code>, <code>UPDATED</code> and <code>REMOVED</code> comments to annotate the lines that have been added, altered or deleted relateive to the previous step.

  section
    h2#intro
      a(href="#intro") Intro
      span  <span class="image-wrapper" data-width="430" data-height="538" data-s3-src="#{post.slug}/i-dont-always-d3.jpg"></span> 
    p D3.js, in case you are unfamiliar with it, is a powerful and flexible JavaScript library that can be used to create interactive data visualizations with HTML, SVG and CSS. D3 stands for Data-Driven Documents and it's behind some of the most innovative and engaging visualizations currently on the web. On <a href="http://d3js.org/" target="_blank">d3js.org</a> you can find a wide variety of examples in addition to extensive documentation. I think it's one of the most exciting projects in the JavaScript ecosystem, and its prolific creator, <a href="http://bost.ocks.org/mike/" target="_blank">Mike Bostock</a>, deserves our collective thanks and admiration.
    p As great as it is, even experienced JavaScript developers can find D3 daunting at first. It can seem like a lot of code is needed to do anything at all and there is <em>so</em> much available in the <a href="https://github.com/mbostock/d3/wiki/API-Reference" target="_blank">D3 namespace</a>. That, however, is simply a byproduct of how flexible it is. The key is to keep calm <span class="image-wrapper" data-width="400" data-height="225" data-s3-src="#{post.slug}/panic.gif"></span> and take it one step at a time. By looking at each small piece on its own and seeing how it fits with the rest of the puzzle, you'll find that patterns start to emerge and that it's not so daunting after all. We're going to be covering a lot of ground in this post, so we'd better get started...
    
  section
    h2#step-1 
      a(href="#step-1") Step 1: A Basic Pie Chart
      span  <span class="image-wrapper" data-width="500" data-height="330" data-s3-src="#{post.slug}/pie-chart.jpg"></span>

    div.panel
      h3#why-a-pie Why a Pie?
      p A few readers will invariably be thinking to themselves, "A pie chart? Really? Pie charts are a <em>terrible</em> way to visualize data. Why would you ever use a pie chart?" Those readers have a valid point. Pie charts are generally not as effective as bar charts because, as humans, <a href="https://en.wikipedia.org/wiki/Pie_chart#Use.2C_effectiveness_and_visual_perception" target="_blank">comparison by angle is harder than comparison by length</a>. However, this post is concerned with the demonstration of fundamental concepts in D3 as opposed to the promotion of one type of visualization over another. For our purposes, the pie/donut chart provides certain advantages; for instance, we won't need to any CSS for the initial steps. It also provides a natural excuse to introduce colour scales. Later posts in this series will look at other plot types, such as the venerable bar plot.
    p To get the ball rolling, we're going to start with a basic pie chart:
    img.centered(src="/img/posts/d3-js-step-by-step-part-1/step-1-pie.png", height="360", width="360")
    p If you were to go to the <a href="/static/d3-js-step-by-step-part-1/step-1-pie.html" target="_blank">demo for this step</a> and inspect the markup generating that chart, you would see the following (ignoring the stuff in the <code>d</code> attribute for now):
    pre#markup-pie
      code.html
        :code
          <div id="chart">
            <svg width="360" height="360">
              <g transform="translate(180,180)">
                <path d="M0,-180A..." fill="#393b79"></path>
                <path d="M105.801..." fill="#5254a3"></path>
                <path d="M171.190..." fill="#6b6ecf"></path>
                <path d="M-105.80..." fill="#9c9ede"></path>
              </g>
            </svg>
          </div>
    p That doesn't look too bad. It's actually pretty easy to see how that corresponds to the pie chart above:
    ul
      li There's a <code>div</code> with the id <em>chart</em>.
      li There's a <code>svg</code> wrapper that defines the width and height.
      li There's a <code>g</code> element that centers the chart (note that 180 is half of 360).
      li There are four <code>path</code> elements that correspond to the four segments in the pie chart, each of which defines a <code>fill</code> colour and a <code>d</code> attribute that specifies the shape and position.
    p If the <code>d</code> attribute wasn't so complicated you could code the whole thing by hand. Luckily D3 is there to do the heavy lifting for you, so let's look at how we can build this up.
    p We'll start by defining some data. Later on we'll load in a more realistic dataset but for now let's just create a simple array with four objects, each of which has a <code>label</code> and a <code>count</code>:
    pre
      code.javascript.
        var dataset = [
          { label: 'Abulia', count: 10 }, 
          { label: 'Betelgeuse', count: 20 },
          { label: 'Cantaloupe', count: 30 },
          { label: 'Dijkstra', count: 40 }
        ];
    p These four entries correspond to the four segments in our chart and to the four <code>path</code> elements in the SVG code above. We could have used a simple array of numbers for this step, but this mimics the structure of the dataset we'll be using later on and, more importantly, with the datasets you're apt to meet in the wild. 
    p Next we'll define some dimensions for our chart:
    pre
      code.javascript.
        var width = 360;
        var height = 360;
        var radius = Math.min(width, height) / 2;     
    p The width and height are self-explanatory. Since pie charts are round, we need a radius, which we set to half of the smaller of the two dimensions. In this case the width and height are the same, but this way we could change one of those without having to also update the radius. Now it's time to put D3 to work for us:
    pre
      code.javascript.
        var color = d3.scale.category20b();
    p This line defines a colour scale for us. D3 provides a few different <a href="https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors" target="_blank">colour scales</a>. If we had more than twenty entries in our dataset, D3 would start to reuse colours. Alternatively we could have used the built-in support for <a href="https://github.com/mbostock/d3/wiki/Ordinal-Scales#colorbrewer" target="_blank">ColorBrewer</a> or defined our own palette by providing an array of colours:
    pre
      code.javascript.
        // Alternative
        var color = d3.scale.ordinal()
          .range(['#A60F2B', '#648C85', '#B3F2C9', '#528C18', '#C3F25C']); 
    p Next we'll create the <code>svg</code> and <code>g</code> elements that we saw in the <a href="#markup-pie">markup</a> earlier:
    pre
      code.javascript.
        var svg = d3.select('#chart')
          .append('svg')
          .attr('width', width)
          .attr('height', height)
          .append('g')
          .attr('transform', 'translate(' + (width / 2) +  ',' + (height / 2) + ')');
    p This might look like a lot of steps, but the key thing&mdash;indeed, the main thesis of this post&mdash;is that:
    blockquote#key-point-1 In D3, each method is specific: it does one thing and it does that one thing very well. This allows it to be highly composable, which is the origin of its flexibility, and that, in turn, is the source of its power.
    p Let's look at that code line by line:
    ol
      li First we use D3's <code>select</code> method to retrieve the DOM element with id <em>chart</em>. If you've used jQuery or something similar this should seem familiar.
      li Next we append an <code>svg</code> element to the element we've selected.
      li Because we're chaining these calls, we now have a reference to the new <code>svg</code> element, so we set its width to be the width we defined earlier on.
      li After the width we set the height.
      li Now we append a <code>g</code> element to the <code>svg</code> element.
      li Finally, becuase our reference is now to the <code>g</code> element, we center it in the containing <code>svg</code> element.
    p All of those steps correspond exactly to the <a href="#markup-pie">markup</a> we examined above. It's exactly the order in which you'd do it if you were doing it by hand. There's no mystery here <span class="image-wrapper" data-width="500" data-height="279" data-s3-src="#{post.slug}/breaking-bad-magic.gif"></span>.
    p With those details out of the way, we can get onto the pie chart itself, for which we need ways of defining two things:
    ol
      li the radius, which determines the size of the overall chart;
      li the start and end angles of each segment.
    p To define the radius we use D3's <code>svg.arc()</code> and provide its <code>outerRadius()</code> method with the radius we defined earlier:
    pre
      code.javascript.
        var arc = d3.svg.arc()
          .outerRadius(radius);
    p For the start and end angles of the segments, we use D3's <code>layout.pie()</code>: 
    pre
      code.javascript.
        var pie = d3.layout.pie()
          .value(function(d) { return d.count; })
          .sort(null);
    p For it we need to define how to extract the numerical data from each entry in our dataset; this is where the <code>count</code> property of the objects we defined earlier comes into play. If we had just had an array of numbers, then instead of returning <code>d.count</code> we could just have returned <code>d</code>. We specify <code>sort(null)</code> to disable <a href="https://github.com/mbostock/d3/wiki/Pie-Layout#sort" target="_blank">sorting</a> of the entries, because a) we have them in the order we want and b) later on sorting will mess with our animation. By default it will sort in order of descending value.
    p Now that we have functions for the radius and the angles, we can take the final step of creating our chart: 
    pre
      code.javascript.
        var path = svg.selectAll('path')
          .data(pie(dataset))
          .enter()
          .append('path')
          .attr('d', arc)
          .attr('fill', function(d, i) { 
            return color(d.data.label);
          });
    p I'll grant that this isn't quite as obvious as the earlier steps&mdash;there's a little magic <span class="image-wrapper" data-width="275" data-height="252" data-s3-src="#{post.slug}/magic.gif"></span> going on here&mdash;but again let's take it line by line:
    ol
      li First we select all <code>path</code> elements inside our <code>svg</code> (or more specifically, inside the <code>g</code> element). At present these don't exist but we're going to create them in a moment.
      li The <code>data()</code> <a href="https://github.com/mbostock/d3/wiki/Selections#data" target="_blank">method</a> is how we associate our dataset with the <code>path</code> elements we're about to create. We do so by passing it through our <code>pie</code> function, which knows how to extract the values and give them meaning in the context of a pie chart.
      li The <code>enter()</code> <a href="https://github.com/mbostock/d3/wiki/Selections#enter" target="_blank">method</a> creates placeholder nodes for each of the values in our dataset.
      li Next we use <code>append()</code> to replace our placeholders with <code>path</code> elements.
      li We define the <code>d</code> attribute&mdash;the complicated one in the <a href="#markup-pie">markup</a>&mdash;using our <code>arc</code> function.
      li Finally we make use of our colour scale to define the <code>fill</code> for each <code>path</code> by associating a colour with each label in the dataset.
    p This is probably the hardest part of the entire post, but there is a silver lining: 
    blockquote#key-point-2 In D3 examples you'll see the <code>.selectAll(el).data(data).enter().append(el)</code> pattern again and again. It's a fundamental set of steps that occurs in many of the most common chart types.
    p In other words, this is not specific to this example; it's representative of something you'll see often when you start digging into D3 code. For me it's a kind of lodestone that helps orient me in a new piece of code.
    p Our basic pie chart is now complete. We can now move on to the next step or pause to consider the code in its entirety along with its accompanying HTML:
    div.lazy-code(data-src="/static/d3-js-step-by-step-part-1/step-1-pie.html", data-language="html")
      button.expand.small.secondary Display Full Code for Step 1

  section
    h2#step-2
      a(href="#step-2") Step 2: A Basic Donut Chart
      span  <span class="image-wrapper" data-width="318" data-height="232" data-s3-src="#{post.slug}/donuts.gif"></span>
    p Food-wise, I much prefer pie to donuts, but when it comes to data viz, donut charts have certain advantages. Primarily because the interior can be put to use, which we'll be doing shortly.
    img.centered(src="/img/posts/d3-js-step-by-step-part-1/step-2-donut.png", height="360", width="360")
    p But how can we make our pie into a donut? I suppose we could create a white circle, make sure its z-index is over 9000, and then position it absolutely over top of the pie. That could work, but it's a terrible idea <span class="image-wrapper" data-width="300" data-height="216" data-s3-src="#{post.slug}/doing-it-wrong.gif"></span>. Instead we're going to make two small additions to the code. First we'll define how wide the donut should be:
    pre
      code.javascript.
        var donutWidth = 75;
    p Next we'll add one line to our definition of <code>arc</code>:
    pre
      code.javascript.
        var arc = d3.svg.arc()
          .innerRadius(radius - donutWidth)  // NEW
          .outerRadius(radius);
    p Ta da! Just like that we've transformed our pie chart into a donut chart. The <code>innerRadius</code> value defaults to 0, which results in a pie. In this case we've set it to be 75px less than the <code>outerRadius</code>, which results in a donut 75px wide.
    p Given that <a href="#step-1">Step 1</a> was a lot to take in, I thought it would be good to coast through this step on easy mode <span class="image-wrapper" data-width="350" data-height="198" data-s3-src="#{post.slug}/easy-mode.gif"></span>. Perhaps it was too simple to even be considered a step, but at any rate we can now march forward or take a peak at the updated code:
    div.lazy-code(data-src="/static/d3-js-step-by-step-part-1/step-2-donut.html", data-language="html")
      button.expand.small.secondary Display Full Code for Step 2
 
  section
    h2#step-3
      a(href="#step-3") Step 3: Adding a Legend
      span  <span class="image-wrapper" data-width="440" data-height="305" data-s3-src="#{post.slug}/legend.jpg"></span>
    p So we have a swanky donut chart, but how are we supposed to know what each segment represents? It's time to add a legend, and we may as well make use of the white space we created when we switched to a donut:
    img.centered(src="/img/posts/d3-js-step-by-step-part-1/step-3-legend.png", height="360", width="360")
    p  If we were to inspect the markup in the <a href="/static/d3-js-step-by-step-part-1/step-3-legend.html" target="_blank">demo</a>, we would see something like this:
    pre#markup-legend
      code.html
        :code
          <g class="legend" transform="translate(-36,-44)">
            <rect width="18" height="18" style="fill: rgb(57, 59, 121); stroke: rgb(57, 59, 121);"></rect>
            <text x="22" y="14">Abulia</text>
          </g>
          <g class="legend" transform="translate(-36,-22)">
            <rect width="18" height="18" style="fill: rgb(82, 84, 163); stroke: rgb(82, 84, 163);"></rect>
            <text x="22" y="14">Betelgeuse</text>
          </g>
          <g class="legend" transform="translate(-36,0)">
            <rect width="18" height="18" style="fill: rgb(107, 110, 207); stroke: rgb(107, 110, 207);"></rect>
            <text x="22" y="14">Cantaloupe</text>
          </g>
          <g class="legend" transform="translate(-36,22)">
            <rect width="18" height="18" style="fill: rgb(156, 158, 222); stroke: rgb(156, 158, 222);"></rect>
            <text x="22" y="14">Dijkstra</text>
          </g>
    p These <code>g</code> elements come after the <code>path</code> elements that we created in <a href="#step-1">Step 1</a>. The coloured squares and text labels are defined by <code>rect</code> and <code>text</code> elements, respectively. This seems straightforward enough. The only tricky bit is the amount by which each <code>g</code> has been translated, but we'll get to that soon enough.
    p Before we proceed any further, an important thing to note is that we've gotten this far without employing any CSS at all <span class="image-wrapper" data-width="460" data-height="345" data-s3-src="#{post.slug}/css.gif"></span>. (You may have noticed the <code>normalize.css</code> file in the full code, but that's just there to do things like strip the margin from the body; it hasn't directly affected our example.) We're going to start this step by defining our first styles:
    pre
      code.html
        :code
          <style>
            .legend {
              font-size: 12px;
            }
            rect {
              stroke-width: 2;
            }
          </style>:
    p This isn't even strictly necessary but it will help make our legend a little prettier. If you've ever done any CSS before, the first declaration should be familiar. The second might look a little weird, although you will recognize <code>rect</code> from the <a href="#markup-legend">markup</a> above. Settings <stroke-width</code> to 2 means that it will have a 2px-wide border.
    p Next we're going to define a couple of size variables so we don't have to hard code any numbers:
    pre
      code.javascript.
        var legendRectSize = 18;
        var legendSpacing = 4;
    p <code>legendRectSize</code> defines the size of the coloured squares you can see above. <code>legendSpacing</code>, not surprisingly, will be used to provide spacing. Now for the meat of it:
    pre
      code.javascript.
        var legend = svg.selectAll('.legend')
          .data(color.domain())
          .enter()
          .append('g')
          .attr('class', 'legend')
          .attr('transform', function(d, i) {
            var height = legendRectSize + legendSpacing;
            var offset =  height * color.domain().length / 2;
            var horz = -2 * legendRectSize;
            var vert = i * height - offset;
            return 'translate(' + horz + ',' + vert + ')';
          });
    p This should look rather familiar. Once again we see the <code>.selectAll(el).data(data).enter().append(el)</code> pattern. And once again, let's take it line by line:
    ol
      li We begin by selecting elements with class <em>legend</em>, which is arbitrarily&mdash;albeit appropriately&mdash;named.
      li We call <code>data()</code> with the domain of our <code>color</code> variable. You may recall that in creating the <code>path</code> elements, we defined the <code>fill</code> attribute using <code>color(d.data.label)</code>. So <code>color.domain()</code> actually refers to an array of labels from our dataset.
      li <code>enter()</code> creates placeholders.
      li We replace our placeholders with <code>g</code> elements.
      li Each <code>g</code> is given a <em>legend</em> class.
      li This last bit isn't something we need to dwell on. I'll go over it in detail but it's just figuring out how to center the legend. We specify how to position each element as follows (keeping in mind that we're operating relative to the <em>center</em> of the SVG rather than the top left corner):
        ol
          li The height of the element is the height of the coloured square plus the spacing.
          li The vertical offset of the <em>entire</em> legend is calculated using the height of a single element and half the total number of elements.
          li The horizontal position&mdash;that is, the left edge of the element&mdash;is shifted left of center by a (somewhat arbitrary) distance equal to the width of two coloured squares. This is meant to provide room for the text.
          li The vertical position&mdash; that is, the top edge of the element&mdash;is shifted up or down from center using the offset defined earlier and the index, <code>i</code>, of the current element, which D3 passes in as the second argument. 
          li Finally we return the translation.
    p As I mentioned, we needn't worry too much about that last part. The key takeaway is:
    blockquote#key-point-3 When iterating over a dataset, D3 provides the index of the current entry as the second parameter to the callback.
    p Now all that remains is to actually add the coloured square and the label. We'll start with the former:
    pre
      code.javascript.
        legend.append('rect')
          .attr('width', legendRectSize)
          .attr('height', legendRectSize)
          .style('fill', color)
          .style('stroke', color);
    p This is straightforward enough that I don't think we need to go over it line by line. I will, however, comment that the <code>fill</code> and <code>stroke</code> are each passed <code>color</code>, from which they can retrieve the appropriate colour for the background and border. Each legend element will pass its label into <code>color()</code>; for instance, the first one will call <code>color('Abulia')</code> and be given <code>#393b79</code> in return.
    p Now for the last part of the legend, the text:
    pre
      code.javascript.
        legend.append('text')
          .attr('x', legendRectSize + legendSpacing)
          .attr('y', legendRectSize - legendSpacing)
          .text(function(d) { return d; });
    p Given the <a href="#markup-legend">markup</a> above, this shouldn't be too surprising. The <code>x</code> and <code>y</code> attributes use the spacing and the size of the coloured square to determine their position <em>relative to the cotainer</em>, the <code>g</code> element with class <em>legend</em>. As such, these attributes are the same for all elements in the legend. Finally, for the <code>text()</code>, we can just give it an identity function becuase we don't need to alter the labels in any way. If, for example, we wanted the to be all uppercase, we could do the following:
    pre
      code.javascript.
        // Alternative
        legend.append('text')
          .attr('x', legendRectSize + legendSpacing)
          .attr('y', legendRectSize - legendSpacing)
          .text(function(d) { return d.toUpperCase(); });
    p So that brings us to the end of our legend. There was a fair bit to it given that we wanted to center it inside the donut. It's worth reiterating that we saw the <code>.selectAll(el).data(data).enter().append(el)</code> pattern come up again. We won't run into it again in this post but I guarantee you'll see it if you start looking at other D3 examples. Now it's time to move on, but first, here's the updated code in case you're interested:
    div.lazy-code(data-src="/static/d3-js-step-by-step-part-1/step-3-legend.html", data-language="html")
      button.expand.small.secondary Display Full Code for Step 3
 
  section
    h2#step-4
      a(href="step-4") Step 4: Loading External Data
      span  <span class="image-wrapper" data-width="392" data-height="235" data-s3-src="#{post.slug}/bad-parking.gif"></span>
    p Up until now our dataset has been rather contrived. 
    img.centered(src="/img/posts/d3-js-step-by-step-part-1/step-4-external-data.png", height="360", width="360")
    div.lazy-code(data-src="/static/d3-js-step-by-step-part-1/step-4-external-data.html", data-language="html")
      button.expand.small.secondary Display Full Code for Step 4

  section
    h2#step-5
      a(href="#step-5") Step 5: Adding Tooltips
      span  <span class="image-wrapper" data-width="450" data-height="300" data-s3-src="#{post.slug}/power-hammer.jpg"></span>
    iframe.centered(src="/static/d3-js-step-by-step-part-1/step-5-tooltips.html", height="380", width="380", seamless)
    div.lazy-code(data-src="/static/d3-js-step-by-step-part-1/step-5-tooltips.html", data-language="html")
      button.expand.small.secondary Display Full Code for Step 5

  section
    h2#step-6
      a(href="#step-6") Step 6: Animating Interactivity
      span  <span class="image-wrapper" data-width="480" data-height="226" data-s3-src="#{post.slug}/at-last-morpheus.gif"></span>
    p Here are are at Step 6.
    iframe.centered(src="/static/d3-js-step-by-step-part-1/step-6-animation.html", height="400", width="380", seamless)
    p View it on <a href="">GitHub</a>, <a href="">S3</a> or you can view it here:
    div.lazy-code(data-src="/static/d3-js-step-by-step-part-1/step-6-animation.html", data-language="html")
      button.expand.small.secondary Display Full Code for Step 6

  section
    div.panel This post grew out of a talk I did on D3 at a <a href="https://twitter.com/DVToronto" target="_blank">DVToronto</a> meetup. The <a href="http://slides.com/kentenglish/getting-started-with-d3-js-using-the-toronto-parking-ticket-data" target="_blank">original slides</a> may also be of interest, although the code has undergone some major changes.

